const { expect: playwrightExpect } = require('@playwright/test');
const util = require('./util');
const logger = require('./logger');

// Função para criar matchers e aplicar asserções
function createMatchers(actual, info) {
    return new Proxy(playwrightExpect(actual), new ExpectMetaInfoProxyHandler(info));
}

// Função para criar o expect com Proxy
function createExpect(info) {
    const expectInstance = new Proxy(playwrightExpect, {
        apply: function (target, thisArg, argumentsList) {
            const [actual, messageOrOptions] = argumentsList;
            const message = typeof messageOrOptions === 'string' ? messageOrOptions : messageOrOptions?.message || info.message;
            const newInfo = { ...info, message };
            
            if (newInfo.isPoll) {
                if (typeof actual !== 'function') {
                    throw new Error('`expect.poll()` aceita apenas funções como primeiro argumento');
                }
                newInfo.generator = actual;
            }
            return createMatchers(actual, newInfo);
        },
        get: function (target, property) {
            // Lida com a configuração do expect (como `not`, `poll`, etc.)
            if (property === 'not') {
                return new Proxy(target, {
                    get: (target, matcher) => {
                        return (...args) => {
                            info.isNot = !info.isNot;
                            return createMatchers(target, info)[matcher](...args);
                        };
                    }
                });
            }
            if (property === 'poll') {
                return (actual, messageOrOptions) => {
                    const poll = typeof messageOrOptions === 'string' ? {} : messageOrOptions || {};
                    return createExpect({ ...info, isPoll: true, poll });
                };
            }
            if (property === 'soft') {
                return (actual, messageOrOptions) => {
                    return createExpect({ ...info, isSoft: true })(actual, messageOrOptions);
                };
            }
            return playwrightExpect[property];
        }
    });
    
    return expectInstance;
}

// Handler para gerenciar meta-informações durante as asserções
class ExpectMetaInfoProxyHandler {
    constructor(info) {
        this._info = { ...info };
    }

    get(target, matcherName, receiver) {
        let matcher = Reflect.get(target, matcherName, receiver);
        if (typeof matcherName !== 'string') return matcher;
        if (matcher === undefined) throw new Error(`Expect: Propriedade '${matcherName}' não encontrada.`);
        if (typeof matcher !== 'function') {
            return matcher;
        }
        if (this._info.isPoll) {
            throw new Error(`\`expect.poll()\` não suporta o matcher "${matcherName}".`);
        }
        return (...args) => {
            logger.info(`Iniciando o matcher: ${matcherName}`);
            return matcher.apply(target, args);
        };
    }
}

// Função utilitária para lidar com polling (métodos de polling em matchers)
async function pollMatcher(matcherName, isNot, pollIntervals, timeout, generator, ...args) {
    const result = await util.pollAgainstDeadline(async () => {
        const value = await generator();
        let expectInstance = playwrightExpect(value);
        if (isNot) expectInstance = expectInstance.not;
        try {
            expectInstance[matcherName].apply(expectInstance, args);
            return { continuePolling: false };
        } catch (error) {
            return { continuePolling: true, result: error };
        }
    }, timeout, pollIntervals || [100, 250, 500, 1000]);
    
    if (result.timedOut) {
        throw new Error(`Timeout ao executar o matcher "${matcherName}".`);
    }
}

// Definindo o custom expect com o Proxy
const expect = createExpect({});

module.exports = { expect };
